# Java
## 1. 자바의 장단점
- 장점
1) JVM에서 독자적으로 동작하기 때문에, 운영체제로부터 독립적이다.
2) 객체지향 언어이다.
3) 오픈 소스다.
4) 스레드 생성 및 제어와 관련된 라이브러리 API를 제공하고 있기 때문에, 쉽게 멀티 스레드를 구현할 수 있다.
5) 애플리케이션을 실핼될 때 모든 객체가 생성되지 않고, 각 객체가 필요한 시점에 클래스를 동적 로딩해서 생성한다. 또한 유지보수시에는 해당 클래스만 수정하면 되기 때문에 전체 애플리케이션을 다시 컴파일할 필요가 없다. 즉, 유지보수가 편리하다.
6) JVM에서 ‘가비지 컬렉터’라 불리는 데몬 쓰레드에 의해서 자동으로 메모리 관리를 해준다.
	* 가비지 컬렉션(Garbage Collection)
		* 변수에 새로운 값을 선언할 때, 원래 값은 메모리에 유지된 채 새로운 값이 메모리에 생성되고 변수는 가리키기만 한다.
		* 때문에 사용하지 않는 값이 메모리 스택에 존재하게 되고, 이를 메모리 누수(Memory Leak)라고 한다.
		* 이런 사용하지 않는 값들을 메모리 스택에서 지워 메모리 누수를 방지하는 방법을 가비지 콜렉션(Garbage Collection)이라 한다.
		~~~
		String url = “https://”     // But 변수 url은 “https”//www.naver.com”만을 가리킨다
		url += “www.naver.com”      // 메모리 스택에는 “https://”와 “https”//www.naver.com”이 존재
		                            // 결과적으로, “https://”는 사용하지 않으므로 메모리 누수가 발생!
		~~~
	(참고 : https://yaboong.github.io/java/2018/06/09/java-garbage-collection/ )
- 단점
1) 속도가 느리다
: 한 번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고, JVM에 의해 기계어로 번역되고 실행하는 과정을 거치기 때문에, C나 C++에 비해 느리다
2) 예외처리가 불편하다
: 프로그래머 검사가 필요한 예외가 등장한다면 무조건 프로그래머가 선언해줘야 한다.

## 2. 자바 접근 제어자 종류
- public  + : 어떤 클래스의 객체에서도 접근 가능
- private  - : 이 클래스에서 생성된 객체들만 접근 가능
- protected  # : 이 클래스와 동일 패키지에 있거나 상속 관계에 있는 하위 클래스의 객체들만 접근 가능
- package  ~ : 동일 패키지에 있는 클래스의 객체들만 접근 가능

## 3. 자바의 데이터 타입
1) 기본형 데이터 타입
- 정수형(byte, short, int, long)
- 실수형(float, double)
- 논리형(boolean)
- 문자형(char)
2) 참조형 테이터 타입
- 기본형 데이터 타입을 제외한 모든 데이터 타입
- new 키워드를 이용해 객체를 생성하고 데이터가 생성된 주소를 참조하는 타입
- String과 배열 타입은 new없이 생성 가능
- 참조 타입의 데이터의 크기가 가변적, 동적이기 때문에 동적으로 관리되는 Heap 영역에 저장된다.
- 더 이상 참조하는 변수가 없을 때 가비지 컬렉션에 의해 파괴된다.
- 참조 타입은 값이 저장된 곳의 주소를 저장하는 공간으로 객체의 주소를 저장한다. (Call-By-Value)

## 4. OOP의 4가지 특징
1) 추상화 : 구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념(집합)으로 다루는 것
- 추상적인 메소드를 활용하면, 변수의 값이 변하더라도 코드를 변경할 필요가 없다.
2) 캡슐화 : 필요가 없는 정보는 외부에서 접근하지 못하도록 제한하는 것 = 정보 은닉(information hiding)
- 높은 응집도와 낮은 결합도를 유지하여, 한 클래스에서 변경이 발생할 경우 다른 클래스에서도 변경이 일어나는 경우를 줄인다
	- 모듈화 : 기능별로 분리
	- 결합도 : 어떤 모듈이 다른 모듈에 의존하는 정도
	- 응집도 : 하나의 모듈이 하나의 기능을 수행하는 요소들간의 연관성 척도
3) 상속 : 여러 개체들이 가진 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립시키는 과정
- 자식 클래스를 외부로부터 은닉하는 캡슐화의 일종
4) 다형성 : 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력

(참고 : https://gmlwjd9405.github.io/2018/07/05/oop-features.html )

## 5. OOP의 5대 원칙 (SOLID)
1) S(단일 책임 원칙 SRP, Single Responsibility Principle)
- 객체는 단 하나의 책임을 가져야 한다 
- 변경 사유가 될만한 것도 하나가 되기 때문에, 응집도를 높일 수 있다
2) O(개반-폐쇄 원칙 OCP, Open Closed Priciple)
- 기존의 코드를 	변경하지 않으면서 추가할 수 있도록 설계되어야 한다
- 변해야 하는 것은 쉽게 변하게 해야 하고, 변하지 말아야 하는 것은 영향을 받지 않게 해야 한다.
3) L(리스코프 치환 원칙 LSP, Liskov Substitution Principle)
- 일반화 관계에 대한 이야기며, 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다
- LSP를 만족하면 부모 클래스의 인터페이스 대신에 자식 클래스의 인터페이스로 대체해도 프로그램의 의미는 변화되지 않는다.
- LSP를 만족시키기 위해서는 재정의하지 않는다(오버라이드).
4) I(인터페이스 분리 원칙 ISP, Interface Segregation Principle)
- 인터페이스를 클라이언트에 특화되도록 분리시키라는 설계 원칙이다
- 클라이언트는 자신이 사용하지 않는 메서드에 생긴 변화로 인한 영향을 받지 않는다.
- ISP를 만족하면 SRP를 만족한다!
5) D(의존 역전 원칙 DIP, Dependency Inversion Principle)
- 의존 관계를 맺을 때, 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존해야한다

( 참고 : https://gmlwjd9405.github.io/2018/07/05/oop-solid.html )
