# 운영체제

## 1. 페이지 교체 알고리즘
1. FIFO (First In First Out)
- 각 페이지가 주기억장치에 적재될 때 마다, 가장 먼저 들어왔던 페이지와 교체한다.
- 프로그래밍 및 설계가 간단하다.
- '벨레이디의 모순'현상이 발생한다.
  - 벨레이디의 모순 : 페이지 프레임 수가 증가하면 일반적으로 페이지 부재(Page Fault)의 수가 감소하지만 반대로 더 많이 발생하는 현상

2. LRU (Least Recently Used)
- 최근에 가장 오랫동안 사용하지 않은 페이지를 교체한다.
- 만약 적재하고자 하는 페이지가 이미 주기억장치에 존재하는 경우, 주기억장치에 있는 페이지의 사용 시간을 초기화한다.
- 최적 알고리즘은 구현이 불가능하므로, LRU를 통해 비슷한 효과를 기대할 수 있다.
- 시간 오버헤드가 크다.

3. LFU (Least Frequently Used)
- 계수 기반(Counting-Based) 페이지 교체 방식이다.
- 사용 빈도가 가장 적은 페이지를 교체한다.
- 교체 대상인 페이지가 여러개인 경우, LRU 방식을 따른다.

4. NUR (Not Used Recently)
- 최근에 사용하지 않은 페이지를 교체한다.
- LRU와 비슷하지만, LRU에서 발생하는 시간 오버헤드를 줄일 수 있다.
- 최근 사용 여부를 확인하기 위해, 각 페이지마다 '참조 비트'와 '변형 비트'를 사용한다.
  - 참조 비트(Reference Bit) : 페이지가 호출되지 않았을 때는 0, 호출되었을 때는 1로 저장된다.
  - 변형 비트(Modified Bit) : 페이지 내용이 변경되지 않았을 때는 0, 변경되었을 때는 1로 지정된다.
  
참조 비트 | 병형 비트 | 교체 순서
--- | --- | ---
0 | 0 | 1
0 | 1 | 2
1 | 0 | 3
1 | 1 | 4

## 2. Process & Thread
1. Mutex & Semaphore
* Critical Section을 보장하기 위해 사용된다.
  * Critical Section(임계구역) : 각 프로세스에서 공유 데이터를 액세스하는 프로그램 코드 부분
  
* Mutex
  * Mutual Exclusion
  * Critical Section을 가진 쓰레드들의 Running Time이 겹치지 않도록 실행시켜주는 기술.
  * 멀티 쓰레드 환경에서 사용
  
* Semaphore
  * 프로세스가 리소스에 접근할 수 있는 상태를 나타내는 카운터
  * 세마포어의 값에 따라 프로세스는 즉시 자원을 사용할 수 있거나, 일정 시간을 기다려야 한다.
  * 멀티 프로세스 환경에서 사용

* Mutex와 Semaphore의 차이점
  * **Mutex는 동기화 대상이 오직 하나지만, Semaphore는 동기화 대상이 하나 이상일 때 사용한다.**
    * Mutex는 상태가 0, 1뿐인 binary semaphore
    * semaphore는 mutex가 될 수 있지만, mutex는 semaphore가 없다!
  * Semaphore는 소유할 수 없는 반면, Mutex는 소유가 가능하며 이에 대한 소유주가 존재합니다.
    * mutex는 상태가 두 개뿐인 lock이므로, lock을 소유할 수 있습니다.
  * Mutex의 경우 Mutex를 보유하고 있는 쓰레드가 Mutex를 해제할 수 없지만, Semahore의 경우 이러한 Semaphore의 경우 이러한 Semaphore를 보유하지 않는 쓰레드가 이 Semaphore를 해제할 수 있습니다.

( 참고 : https://jwprogramming.tistory.com/13 )

2. Lock
* Lock이란?
  * 데이터의 무결성과 일관성을 보장하기 위한 방법

* Lock의 종류
  * Shared Lock(공유 Lock)
    * 데이터를 읽을 때 사용
    * 원하는 데이터에 Lock을 걸었다 하더라도 다른 세션에서 읽을 수 있다.
    * 공유 Lock을 설정한 경우 추가적인 공유 Lock을 설정할 수 있지만, 배타적 Lock을 추가할 수 없다.
  * Exclusive Lock(배타적 Lock)
    * 데이터를 변결할 때 사용
    * 해당 Lock이 해제되기 전까지는 공유, 배타적 Lock을 설정할 수 없다.
    
* Dead Lock
  * 트랜젝션간의 교착상태
  * 두개의 트랜젝션이 서로가 가지고 있는 리소스의 Lock을 획득하기 위해 무한정 대기하는 상태를 말한다.
  
(참고 : https://chrisjune-13837.medium.com/db-lock-%EB%9D%BD%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-d908296d0279)

## 3. Page

1. 가상 메모리(Virtual Memory)
* 윈도우 운영체제의 RAM을 관리하는 방식
* 각 프로그램에 실제 메모리가 아닌 가상 메모리 주소를 할당하여 RAM의 부족한 용량을 보완하기 위해 사용한다.
* 프로세스들의 내용중 덜 중요한 것들은 하드 디스크의 공간으로 옮겨두고, 프로세스 동작중 필요한 데이터가 없으면 하드 디스크에서 찾아 데이터를 가져온다.

2. 프레임 & 페이지
* 프레임(Frame)
  * 물리 메모리를 사용하는 최소 크기 단위
* 페이지(Page)
  * 가상 메모리를 사용하는 최소 크기 단위
* 프레임과 페이지의 크기는 보통 같으며, 페이지는 프레임의 구성요소로 볼 수 있다.
* 운영체제는 페이지 테이블로 가상 메모리를 관리한다.

3. 페이지 폴트(Page Fault)
* 프로그램의 페이지가 물리 메모리에 부재하는 상황
* 물리 메모리에 존재하는 모든 프로세스를 로드하지 않고 스와퍼(Swapper)에 의해 교체가 이루어지기 때문에 발생한다.
* 요구 페이징(Demand Paging) : 페이지 폴트가 발생하여 해당 페이지를 가상 메모리에서 찾는 과정
  1. CPU는 물리 메모리을 확인하여 페이지가 없으면 trap을 발생하여 운영체제에 알린다.
  2. 운영체제는 CPU의 동작을 잠시 멈춘다.
  3. 운영체제는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인하고, 없으면 프로세스를 중단한다.
  4. **페이지 폴트이면, 현재 물리 메모리에 비어있는 프레임(Free Frame)이 있는지 찾는다.**
    * 만약 비어있는 프레임이 없다면, '페이지 교체 알고리즘'에 의해 빈 프레임을 생성한다.
  5. 비어있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화 한다.
  6. 중단되었던 CPU를 다시 시작한다. 
